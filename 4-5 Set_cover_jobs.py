# 그냥 무식하게 입력받은 직업의 해당 자격증들 모조리 추가해서
# 각 자격증별 조합을 생짜로 비교하는 것도 방법일 것 같다.

# U를 어떻게 이식하지 -> 일단 배열을 만들어서 직업별 자격증을 전부 넣은 조합을 만들자
# 직업으로 자격증 추천받기
# 직업별 자격증 목록을 조회해서 중복 없이 전부 배열에 추가한 다음
# 자격증 목록에 대해 집합커버할 수 있는 조합을 집합커버 알고리즘으로 자격증 목록에서 찝어온다.
u = {"정보보호전문가", "정보시스템보안전문가", "투자자산운용사", "약사", "제과기능사, 제빵기능사"}

# S를 어떻게 이식하지 -> 자격증들을 아래처럼 1개 배열 단위로 만들고
# separated 형태로 받아온 다음 통짜로 다시 합치는 과정을 거쳐서 출력
s = [
    {"정보보호전문가", "윤리적해커인증", "정보시스템관리사", "정보시스템보안전문가"},        # s0
    {"석공기능사"}, # s1
    {"투자자산운용사"},     # s2
    {"약사"},        # s3
    {"제과기능사", "제빵기능사"},  # s4
]

print(type(u))
print(u)
print(type(s))
print(s)

job_candidate = []
job_candidate_separated = []
set_cover = []
while len(u) > 0:  # 커버 안된 원소가 있는 동안
    # 가장 많은 원소를 커버하는 집합 인덱스 찾기
    max_cover_set = s.index(max(s, key=lambda x: len(u & x)))
    # print(max_cover_set) n번 요소인지
    # 이렇게 했더니 출력이 됐다. 이게 힌트일 것 같다.
    print(s[max_cover_set]) # n번 요소의 원소들을 출력
    u = u - s[max_cover_set]        # 찾은 집합 원소 제거
    set_cover.append(max_cover_set) # 찾은 집합 인덱스 저장
    job_candidate_separated.append(s[max_cover_set])
    # 통짜로 같은 배열로 만들때
    job_candidate += s[max_cover_set]
    # print(set_cover) # 추가될 때마다 n번이 들어갔는지 출력
    s[max_cover_set] = {-1}         # dummy 집합으로 교체

print('집합 커버를 위한 부분 집합 리스트:', set_cover) # 0, 2, 3, 4

# 이렇게 빼주니까 나옴. 여기서 나오는 조합의 의미: 니가 입력한 조합을 위한 자격증들 전부 다 찍어보았음.
# 일단은 이렇기는 한데, 자격증들이 겹치는 게 뭔가 있으면 좋을 거 같다.
print(job_candidate)
print(job_candidate_separated)

# 일단은 현재 저희가 자료조사한 데이터 특성상 집합 커버는 전부 커버하는 것을 목표하기 때문에 
# 직업별 자격증이 겹치지 않으면 전부 추가를 할 수밖에 없으므로 출력 결과가 이러이러하기는 하지만
# 추후 데이터를 추가할 때 일부 자격증끼리 겹치는 직업의 조합을 입력하면 더욱 효과적인 추천이 가능할 것으로 예상합니다.
